package question

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"log/slog"
	"time"

	"github.com/pkg/errors"
	"github.com/sashabaranov/go-openai"
)

//go:embed service_ai_prompt.txt
var aiSystemPrompt string

// generateQuestionSet generates and stores a set of questions about a given topic.
func (s Service) generateQuestionSet(ctx context.Context, topic Topic, amount int) error {
	var seed int = time.Now().Nanosecond()
	resp, err := s.openaiClient.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model: openai.GPT4Turbo,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: aiSystemPrompt,
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: fmt.Sprintf("Generate %d questions about '%s'", amount, topic),
				},
			},
			Seed:      &seed,
			MaxTokens: 2000,
		},
	)
	if err != nil {
		return errors.Wrap(err, "generating question set")
	}

	var questions []aiQuestion
	if err := json.Unmarshal([]byte(resp.Choices[0].Message.Content), &questions); err != nil {
		return errors.Wrap(err, "unmarshalling questions")
	}
	for _, q := range questions {
		slog.Info("Inserting question", slog.String("question", q.Question))
		parsedQuestion, err := q.toQuestion(topic)
		if err != nil {
			return errors.Wrap(err, "parsing question")
		}
		if err := s.repo.Insert(ctx, *parsedQuestion); err != nil {
			return errors.Wrap(err, "creating question")
		}
	}
	return nil
}

// aiChoice represents a choice generated by the AI.
type aiChoice struct {
	Text      string `json:"text"`
	IsCorrect bool   `json:"isCorrect"`
}

// aiQuestion represents a question generated by the AI.
type aiQuestion struct {
	Question   string     `json:"question"`
	Hint       string     `json:"hint"`
	Choices    []aiChoice `json:"choices"`
	MoreInfo   string     `json:"moreInfo"`
	Difficulty string     `json:"difficulty"`
}

// aiQuestion.toQuestion converts an aiQuestion to a question.Question.
func (a aiQuestion) toQuestion(topic Topic) (*Question, error) {
	difficulty, err := DifficultyString(a.Difficulty)
	if err != nil {
		return nil, errors.Wrap(err, "parsing difficulty")
	}

	q := New(a.Question, a.Hint, a.MoreInfo).
		WithTopic(topic).
		WithDifficulty(difficulty)
	for _, c := range a.Choices {
		q.WithChoice(c.Text, c.IsCorrect)
	}
	return q, nil
}
