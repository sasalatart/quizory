package question

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"log/slog"
	"time"

	"github.com/pkg/errors"
	"github.com/sashabaranov/go-openai"
)

//go:embed service_ai_prompt.txt
var aiSystemPrompt string

// generateQuestionSet generates and stores a set of questions about a given topic.
func (s Service) generateQuestionSet(ctx context.Context, topic Topic, amount int) error {
	results := make(chan questionsResult)
	defer close(results)

	go s.handleQuestionGeneration(ctx, topic, amount, results)

	select {
	case <-ctx.Done():
		return nil
	case result := <-results:
		if result.err != nil {
			return result.err
		}
		for _, q := range result.questions {
			if err := s.repo.Insert(ctx, q); err != nil {
				return errors.Wrap(err, "creating question")
			}
		}
	}
	return nil
}

type questionsResult struct {
	questions []Question
	err       error
}

func (s Service) handleQuestionGeneration(
	ctx context.Context,
	topic Topic,
	amount int,
	results chan questionsResult,
) {
	var seed int = time.Now().Nanosecond()
	resp, err := s.openaiClient.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model: openai.GPT4Turbo,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: aiSystemPrompt,
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: fmt.Sprintf("Generate %d questions about '%s'", amount, topic),
				},
			},
			Seed:      &seed,
			MaxTokens: 2000,
		},
	)
	if err != nil {
		results <- questionsResult{err: errors.Wrap(err, "generating question set")}
		return
	}

	var questions []aiQuestion
	if err := json.Unmarshal([]byte(resp.Choices[0].Message.Content), &questions); err != nil {
		results <- questionsResult{err: errors.Wrap(err, "unmarshalling questions")}
		return
	}

	parsedQuestions := make([]Question, 0, len(questions))
	for _, q := range questions {
		slog.Info("Inserting question", slog.String("question", q.Question))
		parsedQuestion, err := q.toQuestion(topic)
		if err != nil {
			results <- questionsResult{err: errors.Wrap(err, "parsing question")}
			return
		}
		parsedQuestions = append(parsedQuestions, *parsedQuestion)
	}
	results <- questionsResult{questions: parsedQuestions}
}

// aiChoice represents a choice generated by the AI.
type aiChoice struct {
	Text      string `json:"text"`
	IsCorrect bool   `json:"isCorrect"`
}

// aiQuestion represents a question generated by the AI.
type aiQuestion struct {
	Question   string     `json:"question"`
	Hint       string     `json:"hint"`
	Choices    []aiChoice `json:"choices"`
	MoreInfo   string     `json:"moreInfo"`
	Difficulty string     `json:"difficulty"`
}

// aiQuestion.toQuestion converts an aiQuestion to a question.Question.
func (a aiQuestion) toQuestion(topic Topic) (*Question, error) {
	difficulty, err := DifficultyString(a.Difficulty)
	if err != nil {
		return nil, errors.Wrap(err, "parsing difficulty")
	}

	q := New(a.Question, a.Hint, a.MoreInfo).
		WithTopic(topic).
		WithDifficulty(difficulty)
	for _, c := range a.Choices {
		q.WithChoice(c.Text, c.IsCorrect)
	}
	return q, nil
}
